<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>App or Agent Quiz</title>
    <style>
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            top: -10px;
            z-index: 9999;
            animation: confetti-fall linear forwards;
        }

        @keyframes confetti-fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        .celebration-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: white;
            padding: 40px 60px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            z-index: 10000;
            text-align: center;
            animation: celebration-pop 0.5s ease-out forwards;
        }

        @keyframes celebration-pop {
            0% {
                transform: translate(-50%, -50%) scale(0);
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .celebration-message h2 {
            font-size: 2.5em;
            margin-bottom: 10px;
            color: #667eea;
        }

        .celebration-message p {
            font-size: 1.2em;
            color: #4a5568;
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #2d3748;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            color: white;
            margin-bottom: 40px;
            padding: 40px 20px;
        }

        h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .subtitle {
            font-size: 1.2em;
            opacity: 0.95;
            margin-bottom: 20px;
        }

        .stats {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            padding: 15px 25px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            display: block;
        }

        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }

        .progress-bar {
            background: rgba(255, 255, 255, 0.3);
            height: 8px;
            border-radius: 10px;
            margin-top: 20px;
            overflow: hidden;
        }

        .progress-fill {
            background: white;
            height: 100%;
            border-radius: 10px;
            transition: width 0.5s ease;
            width: 0%;
        }

        .quiz-card {
            background: white;
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            border-left: 6px solid #cbd5e0;
        }

        .quiz-card.answered-correct {
            border-left-color: #48bb78;
        }

        .quiz-card.answered-wrong {
            border-left-color: #f56565;
        }

        .quiz-card.answered-tricky {
            border-left-color: #9f7aea;
        }

        .quiz-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.25);
        }

        .spec-label {
            font-size: 0.85em;
            font-weight: 700;
            color: #667eea;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        .quiz-title {
            font-size: 1.5em;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 15px;
            line-height: 1.3;
        }

        .quiz-context {
            color: #4a5568;
            margin-bottom: 25px;
            line-height: 1.6;
            font-size: 1.05em;
        }

        .tricky-note {
            color: #6b46c1;
            font-weight: 600;
            margin-bottom: 20px;
            padding: 12px;
            background: #faf5ff;
            border-radius: 8px;
            border-left: 4px solid #9f7aea;
        }

        .choice-buttons {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .choice-btn {
            flex: 1;
            padding: 18px 24px;
            border: 3px solid #e2e8f0;
            background: white;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }

        .choice-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
            border-color: #667eea;
        }

        .choice-btn:disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .choice-btn.selected-correct {
            background: #c6f6d5;
            border-color: #48bb78;
            color: #22543d;
        }

        .choice-btn.selected-wrong {
            background: #fed7d7;
            border-color: #f56565;
            color: #742a2a;
        }

        .choice-btn.not-selected {
            opacity: 0.4;
        }

        .reveal-btn {
            width: 100%;
            padding: 18px 24px;
            border: 3px solid #9f7aea;
            background: #faf5ff;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: 600;
            color: #6b46c1;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        .reveal-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(159, 122, 234, 0.3);
            background: #f3e8ff;
        }

        .answer-section {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease;
        }

        .answer-section.visible {
            max-height: 2000px;
            margin-top: 20px;
        }

        .answer-content {
            background: #f7fafc;
            padding: 25px;
            border-radius: 12px;
            border-left: 4px solid #667eea;
        }

        .result-badge {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 700;
            font-size: 0.9em;
            margin-bottom: 15px;
        }

        .result-badge.correct {
            background: #c6f6d5;
            color: #22543d;
        }

        .result-badge.wrong {
            background: #fed7d7;
            color: #742a2a;
        }

        .result-badge.tricky {
            background: #e9d8fd;
            color: #6b46c1;
        }

        .answer-label {
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .answer-text {
            color: #4a5568;
            line-height: 1.7;
            margin-bottom: 20px;
        }

        .implementation-box {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid #e2e8f0;
        }

        .implementation-box.app-impl {
        border-left-color: #e2e8f0;
        }

        .implementation-box.agent-impl {
            border-left-color: #e2e8f0;
        }

        .quiz-card[data-answer="app"] .implementation-box.app-impl,
        .quiz-card.answered-tricky .implementation-box.app-impl,
        .quiz-card.answered-tricky .implementation-box.agent-impl {
            border-left-color: #48bb78; 
        }

        .quiz-card[data-answer="agent"] .implementation-box.agent-impl {
            border-left-color: #48bb78;
        }

        .impl-title {
            font-weight: 700;
            margin-bottom: 8px;
            color: #2d3748;
        }

        .impl-text {
            color: #4a5568;
            line-height: 1.6;
        }

        .key-indicator {
            background: #fff5e6;
            padding: 18px;
            border-radius: 8px;
            margin-top: 15px;
            border-left: 4px solid #f6ad55;
        }

        .key-indicator-label {
            font-weight: 700;
            color: #c05621;
            margin-bottom: 8px;
            font-size: 0.95em;
        }

        .key-indicator-text {
            color: #744210;
            line-height: 1.6;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2em;
            }

            .quiz-card {
                padding: 20px;
            }

            .choice-buttons {
                flex-direction: column;
            }
        }
                footer {
            text-align: center;
            margin-top: 50px;
            padding-bottom: 30px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9em;
        }

        footer p {
            line-height: 1.6;
        }

        footer a {
            color: white;
            font-weight: 600;
            text-decoration: none;
            transition: all 0.2s ease;
            border-bottom: 1px solid rgba(255, 255, 255, 0.5);
            padding: 2px 1px;
        }

        footer a:hover {
            background-color: rgba(255, 255, 255, 0.1);
            border-bottom-color: white;
        }
    </style>
</head>

<body>
    <div class="container">
        <div id="mode-selection" style="text-align: center; padding: 60px 20px;">
        <h1 style="color: white; font-size: 3em; margin-bottom: 20px; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);">ü§ñ App or Agent Quiz</h1>
        <p style="color: white; font-size: 1.3em; margin-bottom: 40px; opacity: 0.95;">Read the spec. Decide how to build it.</p>
        
        <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap; max-width: 600px; margin: 0 auto;">
            <button onclick="startQuiz(10)" style="
                flex: 1;
                min-width: 250px;
                padding: 30px;
                background: white;
                border: none;
                border-radius: 16px;
                cursor: pointer;
                transition: all 0.3s ease;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            ">
                <div style="font-size: 2em; margin-bottom: 10px;">‚òï</div>
                <div style="font-size: 1.3em; font-weight: 700; color: #667eea; margin-bottom: 8px;">Quick Practice</div>
                <div style="color: #4a5568; font-size: 0.95em;">10 questions ‚Ä¢ ~5 minutes</div>
            </button>
            
            <button onclick="startQuiz(24)" style="
                flex: 1;
                min-width: 250px;
                padding: 30px;
                background: white;
                border: none;
                border-radius: 16px;
                cursor: pointer;
                transition: all 0.3s ease;
                box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            ">
                <div style="font-size: 2em; margin-bottom: 10px;">üéØ</div>
                <div style="font-size: 1.3em; font-weight: 700; color: #667eea; margin-bottom: 8px;">Full Challenge</div>
                <div style="color: #4a5568; font-size: 0.95em;">24 questions ‚Ä¢ ~15 minutes</div>
            </button>
        </div>
    </div>
        <header style="display: none;">
            <h1>ü§ñ App or Agent Quiz</h1>
            <div class="subtitle">Read the spec. Decide how to build it.</div>
            <div class="stats">
                <div class="stat-card">
                    <span class="stat-number" id="score">0</span>
                    <span class="stat-label">Correct</span>
                </div>
                <div class="stat-card">
                    <span class="stat-number" id="answered">0</span>
                    <span class="stat-label">Answered</span>
                </div>
                <div class="stat-card">
                    <span class="stat-number" id="total-count">0</span>
                    <span class="stat-label">Total</span>
                </div>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
        </header>

        <div id="quiz-container"></div>
        <div id="load-more-container" style="text-align: center; margin: 40px 0; display: none;">
            <button id="load-more-btn" onclick="loadMoreQuestions()" style="
                padding: 20px 40px;
                background: white;
                border: 3px solid #667eea;
                border-radius: 12px;
                font-size: 1.2em;
                font-weight: 600;
                color: #667eea;
                cursor: pointer;
                transition: all 0.3s ease;
                box-shadow: 0 4px 15px rgba(102, 126, 234, 0.2);
            ">
                üéØ Continue with full quiz
            </button>
        </div>
    </div>
    <footer>
        <p>
            A project by <a href="https://github.com/bm-github" target="_blank" rel="noopener noreferrer">bm-github</a>.
            <br>
            View the source code on <a href="https://github.com/bm-github/apporagent" target="_blank" rel="noopener noreferrer">GitHub</a>.
        </p>
    </footer>
    <script>
        let quizData = [{
            spec: "Build a tool that extracts structured data from receipts",
            context: "Users upload photos of receipts. The tool should extract merchant name, date, total amount, and line items into a structured format.",
            answer: "app",
            reasoning: "This is a straightforward transformation task: image ‚Üí structured data. There's no decision-making, no goal-seeking, no uncertainty about what to do next. It performs OCR (likely using a dedicated OCR service like Textract or Tesseract, not an expensive vision model), parses the text, and outputs JSON.",
            appApproach: "Use OCR service ‚Üí parse text with regex/rules ‚Üí validate format ‚Üí return structured JSON",
            agentApproach: "Not needed. The task doesn't require planning, iteration, or decisions about what to do.",
            keyIndicator: "üîç One-way transformation with a clear input and output. No 'what should I do next?' decisions."
        }, {
            spec: "Build a system to manage customer support tickets from start to resolution",
            context: "When a ticket comes in, the system should gather necessary information, determine which team should handle it, escalate when needed, and track through to resolution.",
            answer: "agent",
            reasoning: "This requires multi-step decision-making: What information is missing? Should I ask the customer or check internal systems? Which team is best suited? Is this urgent? Has enough time passed to escalate? Is the issue actually resolved? The system needs to form a plan, adapt based on responses, and determine when its goal (resolved ticket) is achieved.",
            appApproach: "Could build a simple ticket router that classifies and assigns based on keywords, but won't handle the full end-to-end flow described in the spec.",
            agentApproach: "System maintains context across interactions ‚Üí decides what info to gather ‚Üí routes intelligently ‚Üí monitors progress ‚Üí escalates based on reasoning ‚Üí verifies resolution",
            keyIndicator: "üîç Goal-seeking behaviour ('get this ticket resolved'), multi-step decisions, adapts based on context and responses."
        }, {
            spec: "Create a tool that generates email subject lines",
            context: "Given email body content, generate 3-5 subject line options that are attention-grabbing and relevant.",
            answer: "app",
            reasoning: "This is a single-step transformation: email body ‚Üí subject lines. The LLM generates options based on the content, but there's no reasoning about strategy, no decisions about whether the email should even be sent, no consideration of recipient preferences. It's a function call that returns output.",
            appApproach: "Send email body to LLM with prompt ‚Üí receive subject line options ‚Üí return to user",
            agentApproach: "Not needed unless the spec required reasoning like 'should this email be sent now or later?' or 'which recipient segment should get which subject line?'",
            keyIndicator: "üîç Stateless transformation. No memory of previous emails, no strategic decisions, just input ‚Üí output."
        }, {
            spec: "Build a system that monitors production and handles incidents",
            context: "Watch metrics and logs. When something looks wrong, diagnose the issue, attempt fixes, and escalate if needed. Track incidents through resolution.",
            answer: "agent",
            reasoning: "This requires hypothesis formation ('is this a DB issue or network issue?'), deciding what to investigate next, running diagnostic commands, interpreting results, trying different solutions, and determining when the issue is actually resolved. It's iterative problem-solving with uncertain outcomes.",
            appApproach: "Could build alerts and runbooks, but that's just triggering predefined responses, not the adaptive diagnosis described in the spec.",
            agentApproach: "Detect anomaly ‚Üí form hypotheses ‚Üí decide which logs/metrics to check ‚Üí interpret findings ‚Üí try solution ‚Üí verify success ‚Üí iterate if needed ‚Üí escalate if stuck",
            keyIndicator: "üîç Diagnostic reasoning, iterative experimentation, 'done' criteria that the system determines itself."
        }, {
            spec: "Create a documentation search tool",
            context: "Engineers should be able to ask questions and get relevant documentation snippets. Handle queries like 'how do I authenticate?' or 'what's the rate limit?'",
            answer: "app",
            reasoning: "This is semantic search with retrieval: question ‚Üí find relevant docs ‚Üí return snippets. While it uses an LLM for embeddings and possibly reranking, there's no ongoing decision-making. It doesn't ask clarifying questions, doesn't form a learning plan, doesn't decide the engineer needs something different than what they asked for.",
            appApproach: "Query ‚Üí generate embedding ‚Üí search vector DB ‚Üí retrieve and rank relevant chunks ‚Üí return to user",
            agentApproach: "Would involve reasoning like: 'They asked about auth, but based on their role and recent searches, they probably need the OAuth flow specifically, not API keys. Let me ask a clarifying question...'",
            keyIndicator: "üîç Match and retrieve. If it just finds and returns, it's an app. If it reasons about what the user really needs, it's an agent."
        }, {
            spec: "Build a code review assistant",
            context: "When a PR is opened, review the code and provide feedback on potential issues, best practices, and suggestions for improvement.",
            answer: "tricky",
            reasoning: "This depends on the depth of review required. If it's checking linting rules, common bug patterns, and style guides ‚Üí that's an App (pattern matching). If it's evaluating architectural decisions, understanding trade-offs, considering team context, and reasoning about 'is this the right approach for the problem?' ‚Üí that's an Agent.",
            appApproach: "Run linters ‚Üí check against known bug patterns ‚Üí flag style violations ‚Üí surface results",
            agentApproach: "Understand the PR's purpose ‚Üí evaluate if the approach fits the problem ‚Üí reason about trade-offs ‚Üí consider broader codebase context ‚Üí provide architectural feedback ‚Üí ask questions if intent is unclear",
            keyIndicator: "üîç Pattern matching = App. Architectural reasoning and trade-off evaluation = Agent. The spec's phrase 'best practices and suggestions' could go either way!"
        }, {
            spec: "Build a weekly competitor intelligence report generator",
            context: "Every week, produce a report on what our competitors are doing: new features, pricing changes, market moves, hiring, etc.",
            answer: "agent",
            reasoning: "This requires deciding what to investigate, which sources to check, evaluating credibility, determining what's worth including, synthesising findings, and knowing when enough information has been gathered. It's research with judgment calls at every step.",
            appApproach: "Could scrape specific URLs on a schedule and dump changes, but that's just monitoring, not the intelligence analysis the spec describes.",
            agentApproach: "Determine what to investigate this week ‚Üí decide which sources to check ‚Üí evaluate credibility ‚Üí ask follow-up questions based on findings ‚Üí synthesise into coherent narrative ‚Üí determine what's actionable",
            keyIndicator: "üîç Information foraging with judgment ('what's important?'), synthesis, and knowing when to stop researching."
        }, {
            spec: "Create a meeting summarisation tool",
            context: "Record meetings and generate concise summaries with key decisions, action items, and important discussion points.",
            answer: "app",
            reasoning: "This is transcription ‚Üí summarisation. The LLM condenses the transcript and extracts structured information (decisions, action items). There's no planning involved, no decisions about what to do, no iteration. The output is deterministic given the input.",
            appApproach: "Transcribe audio ‚Üí send transcript to LLM with prompt ‚Üí extract key points, decisions, action items ‚Üí format and return",
            agentApproach: "Not needed unless the spec required follow-up like 'determine if action items from last meeting were completed' or 'decide which attendees need which information'.",
            keyIndicator: "üîç One-pass transformation of audio ‚Üí text ‚Üí summary. No decisions about 'what should happen next?'"
        }, {
            spec: "Build an email inbox organiser",
            context: "Automatically organise incoming emails into folders, mark priority emails, and surface what's important.",
            answer: "tricky",
            reasoning: "This could be either depending on implementation. If it's rule-based classification (sender, keywords ‚Üí folder) ‚Üí App. If it understands your priorities, learns from your behaviour, reasons about urgency based on context ('this looks routine but mentions tomorrow's deadline') ‚Üí Agent.",
            appApproach: "Classify emails by sender/subject/keywords ‚Üí apply rules ‚Üí file into folders ‚Üí mark anything from VIP list as priority",
            agentApproach: "Learn user's priorities over time ‚Üí reason about context and urgency ‚Üí understand 'this email seems unimportant but actually requires action' ‚Üí adapt based on user feedback",
            keyIndicator: "üîç Rule-based sorting = App. Reasoning about priorities and context = Agent. The word 'important' in the spec is the tell ‚Äî who decides what's important?"
        }, {
            spec: "Create a test data generator for our API",
            context: "Given our API schema, generate realistic test data that satisfies all constraints and relationships between entities.",
            answer: "app",
            reasoning: "This is schema ‚Üí valid data generation. While it might use an LLM to create realistic-looking names, addresses, etc., there's no decision-making or goal-seeking. It's a function: read schema, generate data that satisfies constraints, return.",
            appApproach: "Parse schema ‚Üí identify constraints ‚Üí generate random data that satisfies them ‚Üí validate ‚Üí return",
            agentApproach: "Not needed. The task has a clear algorithm: generate valid data. No uncertainty about what to do.",
            keyIndicator: "üîç Deterministic generation task with clear constraints. No 'figure out what to do' aspect."
        }, {
            spec: "Build a system that optimises our cloud infrastructure costs",
            context: "Analyse our cloud spending and make changes to reduce costs while maintaining performance. Should handle rightsizing, reserved instances, spot instances, etc.",
            answer: "agent",
            reasoning: "This requires Analysing usage patterns, forming hypotheses about optimisation opportunities, evaluating trade-offs (cost vs. performance vs. reliability), making changes, monitoring impact, and iterating. It's multi-objective optimisation with reasoning at each step.",
            appApproach: "Could generate a report with recommendations, but actually 'making changes' and 'optimising' requires the decision-making the spec describes.",
            agentApproach: "Analyse spending ‚Üí identify opportunities ‚Üí evaluate trade-offs ‚Üí propose changes ‚Üí implement ‚Üí monitor impact ‚Üí adjust if needed ‚Üí iterate",
            keyIndicator: "üîç Multi-objective optimisation with trade-offs, experimentation, and iteration. The word 'optimise' often signals agent behaviour."
        }, {
            spec: "Create a sentiment analysis tool for customer reviews",
            context: "Analyse customer reviews and classify them as positive, negative, or neutral. Include confidence scores.",
            answer: "app",
            reasoning: "This is classification: review text ‚Üí sentiment label. While you might use an LLM, there's no decision-making beyond the classification itself. It's a stateless transformation that outputs a label and confidence score.",
            appApproach: "Send review to LLM or classification model ‚Üí receive sentiment and confidence ‚Üí return result",
            agentApproach: "Not needed. Classification tasks are transformations, not goal-seeking behaviour.",
            keyIndicator: "üîç Fixed classification task. Input ‚Üí output, no decisions about what to do with the result."
        }, {
            spec: "Build a password strength checker",
            context: "Users enter a password and get feedback on its strength with specific recommendations for improvement (add numbers, special characters, etc.).",
            answer: "app",
            reasoning: "This is pure validation: password string ‚Üí strength score + suggestions. It applies deterministic rules (length checks, character variety, common password database lookups). No decisions about what to do next, just evaluate and return feedback.",
            appApproach: "Check password against rules ‚Üí compare to breach databases ‚Üí calculate strength score ‚Üí generate specific improvement suggestions ‚Üí return results",
            agentApproach: "Not needed. The evaluation criteria are fixed and the output is purely based on the input string.",
            keyIndicator: "üîç Rule-based validation with deterministic output. No context or goals beyond the single evaluation."
        }, {
            spec: "Create a personal research assistant for investment decisions",
            context: "Help users research potential investments by gathering data from multiple sources, Analysing trends, checking fundamentals, and providing a reasoned recommendation.",
            answer: "agent",
            reasoning: "This requires deciding what to research, which sources are credible, what metrics matter for this specific investment, reasoning about risk vs. reward, and synthesising findings into a recommendation. Each research path depends on what was learned previously.",
            appApproach: "Could pull predetermined metrics from APIs and display them, but that's just data retrieval, not the research and reasoning the spec describes.",
            agentApproach: "Determine research strategy ‚Üí gather data from multiple sources ‚Üí evaluate credibility ‚Üí identify what's missing ‚Üí dig deeper based on findings ‚Üí reason about risks and opportunities ‚Üí synthesise recommendation",
            keyIndicator: "üîç Multi-step research with adaptive strategy. The system decides what to investigate based on what it learns."
        }, {
            spec: "Build a log parsing and formatting tool",
            context: "Take raw application logs in various formats and convert them to a standardised JSON structure with parsed timestamps, log levels, and messages.",
            answer: "app",
            reasoning: "This is format conversion: raw logs ‚Üí structured JSON. It applies parsing rules, regex patterns, and format transformations. Even if it uses an LLM to handle unusual formats, there's no decision-making beyond the transformation itself.",
            appApproach: "Detect log format ‚Üí apply parsing rules ‚Üí extract fields with regex ‚Üí normalise timestamps ‚Üí validate structure ‚Üí output JSON",
            agentApproach: "Not needed. This is a stateless transformation with clear input/output expectations.",
            keyIndicator: "üîç Format transformation task. No reasoning about what to do with the logs, just parse and structure."
        }, {
            spec: "Create a system that onboards new engineers",
            context: "Guide new hires through setup, documentation, first tasks, and check-ins. Adapt the pace based on their progress and background. Ensure they're ready to contribute.",
            answer: "agent",
            reasoning: "This requires assessing the engineer's background, deciding what they need to learn first, monitoring their progress, adjusting the pace, determining when they're ready for more complex tasks, and knowing when onboarding is complete. It's goal-seeking behavior with constant adaptation.",
            appApproach: "Could provide a static checklist of onboarding steps, but that's not the adaptive guidance the spec describes.",
            agentApproach: "Assess background ‚Üí create personalised plan ‚Üí assign appropriate tasks ‚Üí monitor progress ‚Üí adjust difficulty ‚Üí provide help when stuck ‚Üí determine readiness ‚Üí iterate until fully onboarded",
            keyIndicator: "üîç Goal-driven ('get this person productive') with continuous assessment and adaptation based on individual progress."
        }, {
            spec: "Build a duplicate detection system for user submissions",
            context: "When users submit content (posts, tickets, reports), identify if it's substantially similar to existing submissions and flag potential duplicates.",
            answer: "app",
            reasoning: "This is similarity matching: new submission ‚Üí find near-duplicates in existing data. It uses embeddings or fuzzy matching to compare content, but there's no reasoning about what to do with duplicates or decision-making beyond the matching itself.",
            appApproach: "Generate embedding for new submission ‚Üí search for similar embeddings ‚Üí calculate similarity scores ‚Üí return matches above threshold",
            agentApproach: "Not needed unless the spec required decisions like 'should these be merged?' or 'which is the canonical version?'",
            keyIndicator: "üîç Similarity search and retrieval. If it just finds and flags matches, it's an app."
        }, {
            spec: "Create a content moderation system",
            context: "Review user-generated content for policy violations. Should catch obvious issues automatically, but escalate ambiguous cases for human review with relevant context.",
            answer: "tricky",
            reasoning: "This depends on the level of judgment required. If it's checking against clear rules (banned words, explicit content detection) ‚Üí App. If it's reasoning about context, understanding nuance, evaluating edge cases, and deciding what's truly policy-violating ‚Üí Agent.",
            appApproach: "Run content through classifiers ‚Üí check banned word lists ‚Üí detect explicit content ‚Üí flag matches ‚Üí escalate based on confidence thresholds",
            agentApproach: "Understand content context ‚Üí reason about intent ‚Üí evaluate nuance and edge cases ‚Üí determine severity ‚Üí decide if escalation needed ‚Üí provide reasoning for human reviewers",
            keyIndicator: "üîç Pattern matching and classification = App. Contextual reasoning and judgment calls = Agent. The word 'ambiguous' suggests some agent-like reasoning is expected."
        }, {
            spec: "Build a dynamic pricing calculator",
            context: "Calculate product prices based on current demand, inventory levels, competitor prices, and customer segment. Adjust in real-time to optimise revenue.",
            answer: "agent",
            reasoning: "This requires continuously monitoring multiple signals, reasoning about trade-offs (higher price vs. conversion rate), experimenting with different price points, learning what works, and adapting strategy. It's optimisation with multi-factor decision-making.",
            appApproach: "Could apply a fixed formula based on inputs, but 'optimise revenue' and real-time adaptation requires the strategic reasoning described.",
            agentApproach: "Monitor demand signals ‚Üí evaluate competitor pricing ‚Üí assess inventory ‚Üí reason about customer sensitivity ‚Üí test price points ‚Üí measure outcomes ‚Üí adapt strategy ‚Üí optimise for revenue",
            keyIndicator: "üîç Continuous optimisation with experimentation and learning. The word 'optimise' combined with multiple variables signals agent behavior."
        }, {
            spec: "Create a changelog generator from git commits",
            context: "Scan git history and generate a human-readable changelog with features, fixes, and breaking changes categorised appropriately.",
            answer: "app",
            reasoning: "This is git history ‚Üí formatted changelog. It parses commit messages (possibly using conventional commit patterns), categorises changes, and formats output. While an LLM might improve the descriptions, there's no decision-making or iteration‚Äîjust transformation.",
            appApproach: "Parse git commits ‚Üí categorise by type (feat/fix/breaking) ‚Üí group by category ‚Üí format descriptions ‚Üí generate markdown",
            agentApproach: "Not needed. The task is extracting and reformatting existing information.",
            keyIndicator: "üîç Data extraction and formatting. Input (commits) ‚Üí output (changelog), no strategic decisions."
        }, {
            spec: "Build a system that manages our technical debt",
            context: "Track technical debt across the codebase, prioritise what to address based on impact and effort, and create remediation plans. Monitor progress and adjust priorities.",
            answer: "agent",
            reasoning: "This requires identifying debt, evaluating impact, reasoning about trade-offs (fix now vs. later), prioritising based on team capacity, creating actionable plans, monitoring whether fixes actually worked, and re-prioritising. It's ongoing judgment and adaptation.",
            appApproach: "Could identify code issues with static analysis, but the prioritisation, planning, and adaptive management requires the reasoning described.",
            agentApproach: "Identify debt ‚Üí evaluate business impact ‚Üí assess effort required ‚Üí reason about priorities ‚Üí create remediation plan ‚Üí monitor progress ‚Üí adjust based on outcomes ‚Üí iterate",
            keyIndicator: "üîç Continuous prioritisation with trade-off evaluation and adaptive planning. Multiple feedback loops."
        }, {
            spec: "Create an API response caching layer",
            context: "Cache API responses intelligently based on request patterns, invalidate when data changes, and optimise cache hit rates.",
            answer: "tricky",
            reasoning: "This could be either. If it's rule-based (cache for X minutes, invalidate on updates) ‚Üí App. If it's learning patterns, reasoning about what should be cached, predicting cache utility, and adapting strategy ‚Üí Agent.",
            appApproach: "Cache responses with TTL ‚Üí invalidate on write operations ‚Üí return cached data on hits ‚Üí standard cache eviction policies",
            agentApproach: "Learn request patterns ‚Üí predict cache value ‚Üí reason about when to preload ‚Üí adapt TTL based on data change frequency ‚Üí optimise strategy based on hit rates",
            keyIndicator: "üîç Rule-based caching = App. Learning and adaptive optimisation = Agent. The word 'intelligently' and 'optimise' suggest more than basic caching."
        }, {
            spec: "Build an SQL query generator from natural language",
            context: "Users describe what data they want in plain English, and the system generates the appropriate SQL query to retrieve it from our database.",
            answer: "app",
            reasoning: "This is natural language ‚Üí SQL translation. While it uses an LLM, there's no iteration or decision-making beyond the translation. It converts intent to query syntax and returns it. The user executes it.",
            appApproach: "Parse natural language intent ‚Üí understand database schema ‚Üí generate SQL query ‚Üí validate syntax ‚Üí return query",
            agentApproach: "Would involve executing queries, checking results, refining if wrong, reasoning about performance, and iterating until the right data is retrieved.",
            keyIndicator: "üîç One-way translation task. If it just generates the query without executing and verifying results, it's an app."
        }, {
            spec: "Create a system that coordinates deployments across microservices",
            context: "When deploying updates, determine deployment order based on dependencies, monitor health checks, rollback if issues detected, and ensure zero-downtime transitions.",
            answer: "agent",
            reasoning: "This requires planning deployment order, monitoring during execution, detecting problems, deciding whether to continue or rollback, potentially retrying, and determining when the deployment is truly successful. It's orchestration with continuous decision-making.",
            appApproach: "Could follow a static deployment pipeline, but the adaptive monitoring, decision-making, and rollback logic described requires agent reasoning.",
            agentApproach: "Analyse dependencies ‚Üí plan deployment order ‚Üí execute in stages ‚Üí monitor health ‚Üí detect issues ‚Üí decide continue/rollback ‚Üí retry if needed ‚Üí verify success",
            keyIndicator: "üîç Orchestration with continuous monitoring and adaptive decision-making. Multiple 'what should I do?' decision points."
        }];
        let score = 0;
        let answered = 0;

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function checkIfShouldShowLoadMore() {
            // Only show load more if they started with Quick Practice (10 questions)
            // and have completed all current questions
            if (initialChoice === 10 && answered === quizData.length && quizData.length < fullQuizData.length) {
                document.getElementById('load-more-container').style.display = 'block';
            }
        }

        function createQuizCard(item, index) {
            const card = document.createElement('div');
            card.className = 'quiz-card';
            card.dataset.index = index;
            card.dataset.answer = item.answer;

            const isTricky = item.answer === 'tricky';
            const trickyNote = isTricky ? '<div class="tricky-note">‚ö†Ô∏è This one could go either way depending on implementation!</div>' : '';

            // Reverting to conditional buttons: Reveal for tricky, choices for others
            const buttonsHTML = isTricky ? `
                <button class="reveal-btn" onclick="revealTrickyAnswer(${index})">
                    üîç Reveal Answer
                </button>
            ` : `
                <div class="choice-buttons">
                    <button class="choice-btn" onclick="selectAnswer(${index}, 'app')">
                        <span>üîß</span> <span>App</span>
                    </button>
                    <button class="choice-btn" onclick="selectAnswer(${index}, 'agent')">
                        <span>ü§ñ</span> <span>Agent</span>
                    </button>
                </div>
            `;

            card.innerHTML = `
                <div class="spec-label">üìã Product Spec</div>
                <div class="quiz-title">${item.spec}</div>
                <div class="quiz-context">${item.context}</div>
                ${trickyNote}
                ${buttonsHTML}
                <div class="answer-section">
                    <div class="answer-content">
                        <div class="result-message"></div>
                        <div class="answer-label">Why:</div>
                        <div class="answer-text">${item.reasoning}</div>
                        
                        <div class="implementation-box app-impl">
                            <div class="impl-title">üîß App Approach:</div>
                            <div class="impl-text">${item.appApproach}</div>
                        </div>
                        
                        <div class="implementation-box agent-impl">
                            <div class="impl-title">ü§ñ Agent Approach:</div>
                            <div class="impl-text">${item.agentApproach}</div>
                        </div>

                        <div class="key-indicator">
                            <div class="key-indicator-label">üéØ Key Indicator:</div>
                            <div class="key-indicator-text">${item.keyIndicator}</div>
                        </div>
                    </div>
                </div>
            `;

            return card;
        }

        // Reinstated function for tricky questions
        function revealTrickyAnswer(index) {
            const card = document.querySelector(`[data-index="${index}"]`);
            const answerSection = card.querySelector('.answer-section');
            const resultMessage = card.querySelector('.result-message');
            const revealBtn = card.querySelector('.reveal-btn');

            // Prevent multiple reveals
            if (card.classList.contains('answered-tricky')) {
                return;
            }

            // Update stats (tricky questions always count as correct)
            answered++;
            score++;
            card.classList.add('answered-tricky');

            // Disable reveal button
            revealBtn.disabled = true;
            revealBtn.style.opacity = '0.5';
            revealBtn.style.cursor = 'not-allowed';

            // Show result message
            resultMessage.innerHTML = '<div class="result-badge tricky">‚ú® Both approaches can work!</div>';

            // Show answer
            answerSection.classList.add('visible');

            // Update stats
            updateStats();

            // Scroll to show answer
            setTimeout(() => {
                answerSection.scrollIntoView({
                    behavior: 'smooth',
                    block: 'nearest'
                });
            }, 100);
        }

        // Adapted function for standard questions (only triggered if 'tricky' is not the answer)
        function selectAnswer(index, choice) {
            const card = document.querySelector(`[data-index="${index}"]`);
            const correctAnswer = card.dataset.answer;
            const buttons = card.querySelectorAll('.choice-btn');
            const answerSection = card.querySelector('.answer-section');
            const resultMessage = card.querySelector('.result-message');

            // Prevent multiple answers
            if (card.classList.contains('answered-correct') || card.classList.contains('answered-wrong')) {
                return;
            }

            const isCorrect = choice === correctAnswer;

            // Update score
            answered++;
            if (isCorrect) {
                score++;
                card.classList.add('answered-correct');
            } else {
                card.classList.add('answered-wrong');
            }

            // Update buttons
            buttons.forEach(btn => {
                btn.disabled = true;
                const btnType = btn.textContent.includes('App') ? 'app' : 'agent';

                if (btnType === choice) {
                    btn.classList.add(isCorrect ? 'selected-correct' : 'selected-wrong');
                } else {
                    btn.classList.add('not-selected');
                }
            });

            // Show result message
            if (isCorrect) {
                resultMessage.innerHTML = '<div class="result-badge correct">‚úì Correct!</div>';
            } else {
                resultMessage.innerHTML = `<div class="result-badge wrong">‚úó Not quite ‚Äî this is an ${correctAnswer}</div>`;
            }

            // Show answer
            answerSection.classList.add('visible');

            // Update stats
            updateStats();

            // Scroll to show answer
            setTimeout(() => {
                answerSection.scrollIntoView({
                    behavior: 'smooth',
                    block: 'nearest'
                });
            }, 100);
        }
        
        function updateStats() {
            const totalCount = quizData.length;
            document.getElementById('score').textContent = score;
            document.getElementById('answered').textContent = answered;
            document.getElementById('total-count').textContent = totalCount;

            const progress = totalCount > 0 ? (answered / totalCount) * 100 : 0;
            document.getElementById('progress-fill').style.width = `${progress}%`;

            // Check if all questions have been answered to potentially show celebration or load more
            if (answered > 0 && answered === totalCount) {
                if (score === totalCount) {
                    triggerCelebration();
                }
                checkIfShouldShowLoadMore();
            }
        }

        function renderQuiz() {
            const container = document.getElementById('quiz-container');
            container.innerHTML = '';

            quizData.forEach((item, index) => {
                container.appendChild(createQuizCard(item, index));
            });
        }
        function triggerCelebration() {
            // Create celebration message
            const message = document.createElement('div');
            message.className = 'celebration-message';
            message.innerHTML = `
                <h2>üéâ Perfect Score! üéâ</h2>
                <p>You've mastered App or Agent thinking!</p>
            `;
            document.body.appendChild(message);

            // Remove message after 3 seconds
            setTimeout(() => {
                message.style.animation = 'celebration-pop 0.3s ease-in reverse';
                setTimeout(() => message.remove(), 300);
            }, 3000);

            // Create confetti
            const colors = ['#667eea', '#764ba2', '#48bb78', '#ed8936', '#f56565', '#9f7aea'];
            for (let i = 0; i < 100; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * 100 + '%';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDuration = (Math.random() * 3 + 2) + 's';
                    confetti.style.animationDelay = '0s';
                    document.body.appendChild(confetti);

                    setTimeout(() => confetti.remove(), 5000);
                }, i * 30);
            }
        }
        function loadMoreQuestions() {
            const previousCount = quizData.length;
            const newCount = Math.min(previousCount + 10, fullQuizData.length);
            
            quizData = fullQuizData.slice(0, newCount);
            
            // Render only the new questions
            const container = document.getElementById('quiz-container');
            for (let i = previousCount; i < newCount; i++) {
                container.appendChild(createQuizCard(quizData[i], i));
            }
            
            updateStats();
            
            // Hide button if all questions loaded
            if (newCount >= fullQuizData.length) {
                document.getElementById('load-more-container').style.display = 'none';
            }
        }

        function checkIfShouldShowLoadMore() {
            // Count answered questions in current batch
            const currentBatchAnswered = answered;
            const currentBatchTotal = quizData.length;
            
            // Show continue quiz button if all current questions answered and more available
            if (currentBatchAnswered === currentBatchTotal && quizData.length < fullQuizData.length) {
                document.getElementById('load-more-container').style.display = 'block';
            }
        }
        function startQuiz(questionCount) {
            // Hide mode selection
            document.getElementById('mode-selection').style.display = 'none';
            
            // Show header
            document.querySelector('header').style.display = 'block';
            
            // Set up quiz with selected count
            displayCount = questionCount;
            initialChoice = questionCount; // Track what they originally chose
            quizData = fullQuizData.slice(0, displayCount);
            updateStats();
            renderQuiz();
        }

        // Initialize - don't set up quiz until mode is selected
        let displayCount = 10;
        let initialChoice = 10;
        let fullQuizData = shuffleArray([...quizData]); // Shuffle a copy of the original data
        quizData = []; // Clear until mode selected
    </script>
</body>

</html>